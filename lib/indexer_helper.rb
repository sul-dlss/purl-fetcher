module IndexerHelper

  def indexer_config
    PurlFetcher::Application.config.solr_indexing
  end

  def log
    @log ||= Logger.new('log/indexing.log')
  end

  def modified_at_or_later
    indexer_config['default_run_interval_in_minutes'].to_i.minutes.ago # default setting
  end

  # Create a object that can be used for RSolr Calls
  #
  # @return [RSolr::Client]
  def establish_solr_connection
    RSolr.connect(url: PurlFetcher::Application.config.solr_url, retry_503: 5, retry_after_limit: 15)
  end

  # Get a list of all documents modified between two times from solr
  #
  # @param first_modified [String] The time the object was first modifed, a string that can be parsed into a valid ISO 8601 formatted time
  # @param last_modified [String] The latest time the object wasmodifed, a string that can be parsed into a valid ISO 8601 formatted time
  # @return [Hash] JSon formatted solr response
  def get_modified_from_solr(first_modified: Time.zone.at(0).iso8601, last_modified: (Time.zone.now + 5.minutes).utc.iso8601)
    times = ModificationTime.get_times(first_modified: first_modified, last_modified: last_modified)
    mod_field = indexer_config['change_field']
    query = "* AND -#{indexer_config['deleted_field']}:'true' AND #{mod_field}:[\"#{times[:first]}\" TO \"#{times[:last]}\"]"
    response = run_solr_query(query)
    format_modified_response(response)
  end

  # Get a list of all documents deleted between two times from solr
  #
  # @param first_modified [String] The time the object was first modifed, a string that can be parsed into a valid ISO 8601 formatted time
  # @param last_modified [String] The latest time the object wasmodifed, a string that can be parsed into a valid ISO 8601 formatted time
  # @return [Hash] JSon formatted solr response
  def get_deletes_list_from_solr(first_modified: Time.zone.at(0).iso8601, last_modified: (Time.zone.now + 5.minutes).utc.iso8601)
    times = ModificationTime.get_times(first_modified: first_modified, last_modified: last_modified)
    mod_field = indexer_config['change_field']
    query = "* AND #{indexer_config['deleted_field']}:'true' AND #{mod_field}:[\"#{times[:first]}\" TO \"#{times[:last]}\"]"
    solr_resp = run_solr_query(query)

    # TODO: Refactor this and the stuff from format_modified_response into one function
    response = { 'deletes' => [] }

    solr_resp['response']['docs'].each do |doc|
      response['deletes'] << { 'druid' => doc['id'], 'latest_change' => doc['timestamp'] }
    end
    response
  end

  # Establishes a connection to solr and runs a select query and returns the response.  Logs errors and swallows them.
  #
  # @param query [String] A valid query that the RSolr gem will understand how to process via the get method
  # @return [Hash] The solr response.  An empty hash is returned if nothing is found or there is an error.
  def run_solr_query(query)
    solr_client = establish_solr_connection
    response = {}
    begin
      with_retries(max_retries: 5, base_sleep_seconds: 3, max_sleep_seconds: 15, rescue: RSolr::Error) do
        response = solr_client.get 'select', params: { q: query.to_s, rows: 100_000_000 }
      end
    rescue StandardError => e
      log.error("Unable to select from documents using the query #{query}, solr returned a response of #{response} and an exception of #{e.message} occurred, #{e.backtrace.inspect} ")
      return {} # Could return the Exception as well if ever desired, just logs for now
    end
    response
  end

  # Takes a solr response and formats it into JSON for the users
  #
  # @param solr_resp [Hash] A Hash generated by an RSolr query
  # @return [Hash] The respnse with unwanted fields removed
  def format_modified_response(solr_resp)
    response = { 'changes' => [] }
    solr_resp['response']['docs'].each do |doc|
      hash = { 'druid' => doc['id'], 'latest_change' => doc['timestamp'] }
      hash['true_targets']  = doc[indexer_config['released_true_field']] unless doc[indexer_config['released_true_field']].nil?
      hash['false_targets'] = doc[indexer_config['released_false_field']] unless doc[indexer_config['released_false_field']].nil?
      response['changes'] << hash
    end
    response
  end

end
